# -*- coding: utf-8 -*-
"""Dashboard

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VXreJjX4GmxSZr0Tpvga7cOPW_DlvfvT
"""

# prompt: import getpass

import getpass

# Example usage:
password = getpass.getpass(prompt='Enter your password: ')
print("Password entered successfully!") # You would typically use the password here
# ... your code continues ...

import pandas as pd
import numpy as np
from sklearn.linear_model import LinearRegression

# prompt: INSTALL PLOTLY

!pip install plotly

# prompt: INSTALL scikit-learn

!pip install scikit-learn

# prompt: INSTALL TENSORFLOW

!pip install tensorflow

streamlit run dashboard.py

# prompt: install finRL

!pip install git+https://github.com/AI4Finance-LLC/FinRL-Library.git

# prompt: install streamlit

!pip install streamlit

# Commented out IPython magic to ensure Python compatibility.
# # prompt: export streamlit via .py and run via bash
# 
# %%writefile app.py
# import streamlit as st
# import pandas as pd
# import kagglehub
# 
# # Download latest version
# path = kagglehub.dataset_download("mczielinski/bitcoin-historical-data")
# 
# # Assuming the downloaded dataset is a CSV file named 'bitstampUSD_1-min_data_2012-01-01_to_2021-03-31.csv'
# # Replace with the actual filename if different.
# try:
#     df = pd.read_csv(path + '/bitstampUSD_1-min_data_2012-01-01_to_2021-03-31.csv')
#     st.write(df.head())
# except FileNotFoundError:
#     st.write(f"Error: File not found at {path}/bitstampUSD_1-min_data_2012-01-01_to_2021-03-31.csv")
# except Exception as e:
#     st.write(f"An error occurred: {e}")
#

pip install streamlit-option-menu

!pip install yfinance
import yfinance as yf
data = yf.download("AAPL", period="1y")

from google.colab import files
uploaded = files.upload()

# prompt: process the data from btcusd_1-min_data.csv

file_name = 'btcusd_1-min_data.csv' # Assuming the file is uploaded and named this way
try:
    df_btc = pd.read_csv(file_name)
    print(f"Successfully loaded {file_name}")
    print(df_btc.head()) # Print the first few rows to inspect the data
    print(df_btc.info()) # Print info about the dataframe

    # Perform some basic data cleaning or processing if needed
    # Example: Convert 'date' column to datetime if it exists and is not already
    if 'date' in df_btc.columns:
        df_btc['date'] = pd.to_datetime(df_btc['date'], unit='s') # Assuming 'date' is a unix timestamp
        df_btc.set_index('date', inplace=True) # Set date as index
        print("\nAfter converting 'date' and setting index:")
        print(df_btc.head())

    # Example: Handle missing values (e.g., fill with mean or drop rows)
    if df_btc.isnull().sum().sum() > 0:
        print(f"\nMissing values before handling:\n{df_btc.isnull().sum()}")
        df_btc.dropna(inplace=True) # Example: drop rows with any missing values
        print(f"\nMissing values after handling:\n{df_btc.isnull().sum()}")

    # Example: Calculate a simple moving average
    if 'close' in df_btc.columns:
        df_btc['SMA_10'] = df_btc['close'].rolling(window=10).mean()
        print("\nAfter calculating SMA_10:")
        print(df_btc.head())

except FileNotFoundError:
    print(f"Error: The file '{file_name}' was not found. Please make sure you uploaded it correctly.")
except Exception as e:
    print(f"An error occurred during file processing: {e}")

# You can now use the processed dataframe `df_btc` for further analysis or modeling.

# Simple strategy: Buy when short MA > long MA
df['SMA20'] = df['Close'].rolling(window=20).mean()
df['SMA50'] = df['Close'].rolling(window=50).mean()
df['Signal'] = 0
df['Signal'][df['SMA20'] > df['SMA50']] = 1  # Buy
df['Signal'][df['SMA20'] <= df['SMA50']] = 0  # Sell or Hold

# Plotting
import matplotlib.pyplot as plt

plt.figure(figsize=(12,6))
plt.plot(df['Close'], label='Close Price')
plt.plot(df['SMA20'], label='SMA20')
plt.plot(df['SMA50'], label='SMA50')
plt.legend()
plt.show()

from apscheduler.schedulers.blocking import BlockingScheduler

sched = BlockingScheduler()

@sched.scheduled_job('5', minutes=5)
def scheduled_trade():
    exec(open("alpaca_bot.py").read())

sched.start()

# prompt: stop loss <$300, take profit >$10. drawndown of 5-10%

# Function to execute a trade with stop-loss and take-profit
def execute_trade_with_sl_tp(symbol, quantity, limit_price, stop_loss_price, take_profit_price):
    try:
        # Ensure account is active
        account = api.get_account()
        if account.status != 'ACTIVE':
            print(f"Account is not active. Current status: {account.status}")
            return

        # Place a limit order with stop-loss and take-profit
        order = api.submit_order(
            symbol=symbol,
            qty=quantity,
            side='buy',  # or 'sell'
            type='limit',
            time_in_force='gtc',  # Good 'Til Canceled
            limit_price=str(limit_price),
            order_class='bracket',
            stop_loss=dict(
                stop_price=str(stop_loss_price),
            ),
            take_profit=dict(
                limit_price=str(take_profit_price),
            )
        )
        print(f"Bracket order placed for {symbol}: {order}")
    except Exception as e:
        print(f"Error executing trade for {symbol}: {e}")

# Example Usage:
# Assuming df has 'Close' price data
if not df.empty and 'Close' in df.columns:
    latest_price = df['Close'].iloc[-1] # Get the latest closing price

    # Define parameters based on latest price and desired conditions
    limit_price = latest_price
    # Stop loss $300 below the limit price
    stop_loss_price = latest_price - 300
    # Take profit $10 above the limit price
    take_profit_price = latest_price + 10

    # Ensure stop loss is not below zero and take profit is above stop loss
    if stop_loss_price > 0 and take_profit_price > stop_loss_price:
        execute_trade_with_sl_tp(
            symbol="AAPL",
            quantity=10, # Example quantity
            limit_price=limit_price,
            stop_loss_price=stop_loss_price,
            take_profit_price=take_profit_price
        )
    else:
        print("Invalid stop loss or take profit prices calculated.")
else:
    print("DataFrame is empty or does not contain 'Close' column.")

# To check for drawdown (5-10%) retrospectively or during trading,
# you would need to track the peak value of your portfolio or a specific position
# and monitor how much it has fallen from that peak. This typically involves
# storing historical portfolio values and calculating the percentage drop.

# Example of tracking drawdown (conceptual, not directly integrated with live trading)
def calculate_drawdown(portfolio_values):
    if not portfolio_values:
        return 0

    peak = -np.inf
    max_drawdown = 0

    for value in portfolio_values:
        if value > peak:
            peak = value
        drawdown = (peak - value) / peak if peak > 0 else 0
        max_drawdown = max(max_drawdown, drawdown)

    return max_drawdown

# To use this, you would need a list or series of your historical portfolio values:
# For example:
# historical_portfolio_values = [10000, 10100, 9900, 10500, 9800, 9500]
# current_drawdown = calculate_drawdown(historical_portfolio_values)
# print(f"Current Drawdown: {current_drawdown * 100:.2f}%")

# To implement a drawdown limit within a trading bot, you would need to:
# 1. Regularly track your portfolio value.
# 2. Maintain the historical peak portfolio value.
# 3. Calculate the current drawdown.
# 4. If the drawdown exceeds your threshold (e.g., 10%), consider reducing position size or stopping trading.

# This requires more complex state management and logic within your trading strategy.
# The provided code focuses on setting stop-loss and take-profit for individual trades.

# prompt: GIVEN PRICE AND VOLUME, PREDICT UP AND DOWN BASED ON THE IMPORTEED FILE

# Function to predict price movement (Up/Down) based on simple moving average crossover
def predict_movement(df):
    """
    Predicts 'Up' or 'Down' based on SMA crossover.

    Args:
        df (pd.DataFrame): DataFrame with 'Close', 'SMA20', and 'SMA50' columns.

    Returns:
        str: 'Up' if SMA20 > SMA50, 'Down' otherwise.
             Returns 'Insufficient Data' if required columns are missing or DataFrame is empty.
    """
    if df.empty or 'Close' not in df.columns or 'SMA20' not in df.columns or 'SMA50' not in df.columns:
        return 'Insufficient Data'

    # Get the latest signal
    latest_signal = df['Signal'].iloc[-1]

    if latest_signal == 1:
        return 'Up'
    else:
        return 'Down'

# Assuming df_btc is the DataFrame loaded and processed from the uploaded CSV
# Check if df_btc is available and has the necessary columns before using it
if 'df_btc' in globals() and not df_btc.empty and 'close' in df_btc.columns:
    # Rename 'close' to 'Close' to match the function's expectation
    df_btc = df_btc.rename(columns={'close': 'Close'})

    # Recalculate SMA20 and SMA50 on df_btc
    df_btc['SMA20'] = df_btc['Close'].rolling(window=20).mean()
    df_btc['SMA50'] = df_btc['Close'].rolling(window=50).mean()

    # Recalculate the Signal on df_btc
    df_btc['Signal'] = 0
    # Using .loc to avoid SettingWithCopyWarning
    df_btc.loc[df_btc['SMA20'] > df_btc['SMA50'], 'Signal'] = 1  # Buy
    df_btc.loc[df_btc['SMA20'] <= df_btc['SMA50'], 'Signal'] = 0  # Sell or Hold

    # Predict the movement
    predicted_movement = predict_movement(df_btc.dropna(subset=['SMA20', 'SMA50', 'Signal'])) # Drop NaNs introduced by rolling window

    if predicted_movement != 'Insufficient Data':
        print(f"\nPredicted price movement based on SMA crossover: {predicted_movement}")
    else:
        print("\nCould not predict movement: DataFrame is empty or missing required columns after processing.")

else:
    print("\nDataFrame df_btc is not available or does not contain the 'close' column.")

# prompt: TRADING AI TO ONLY BUY, NO SHORTNING

# The existing strategy uses SMA crossover to generate buy (1) and sell (0) signals.
# To make it only BUY, we need to modify the Signal generation logic.
# We will keep the Signal at 1 when SMA20 > SMA50 and 0 otherwise,
# but in the actual trading execution part, we will only act on BUY signals (Signal == 1).

# The core logic modification happens in the part where trades are executed.
# The current `execute_trade_with_sl_tp` function places a buy order.
# We need to wrap the call to this function with a condition that checks the signal.

# Assuming the DataFrame `df` or `df_btc` (whichever is used for signals) is updated with the latest data and signals

# --- Code to update df_btc with signals (copied and slightly adjusted from previous) ---
if 'df_btc' in globals() and not df_btc.empty and 'close' in df_btc.columns:
    # Rename 'close' to 'Close' to match the function's expectation (if needed)
    if 'Close' not in df_btc.columns:
        df_btc = df_btc.rename(columns={'close': 'Close'})

    # Recalculate SMA20 and SMA50 on df_btc
    df_btc['SMA20'] = df_btc['Close'].rolling(window=20).mean()
    df_btc['SMA50'] = df_btc['Close'].rolling(window=50).mean()

    # Recalculate the Signal on df_btc (unchanged logic for signal generation)
    df_btc['Signal'] = 0
    # Using .loc to avoid SettingWithCopyWarning
    df_btc.loc[df_btc['SMA20'] > df_btc['SMA50'], 'Signal'] = 1  # Buy
    df_btc.loc[df_btc['SMA20'] <= df_btc['SMA50'], 'Signal'] = 0  # Sell or Hold

    print("\nDataFrame df_btc updated with SMAs and Signals.")
    print(df_btc[['Close', 'SMA20', 'SMA50', 'Signal']].tail())

else:
    print("\nDataFrame df_btc is not available or does not contain the 'close' column needed for signal generation.")
# --- End of signal generation update ---


# --- Modification to the trading logic ---

# You would typically have a trading execution block that runs based on the signal.
# This is where you add the condition to only buy.

# Example of how you might integrate this with the `execute_trade_with_sl_tp` function:

# Assuming you have initialized your Alpaca API client as `api`

# Get the latest signal from the processed DataFrame
if 'df_btc' in globals() and not df_btc.empty and 'Signal' in df_btc.columns:
    latest_signal = df_btc['Signal'].iloc[-1] # Get the latest calculated signal

    print(f"\nLatest trading signal: {latest_signal}")

    # Define parameters based on latest price and desired conditions
    if 'Close' in df_btc.columns:
        latest_price = df_btc['Close'].iloc[-1] # Get the latest closing price

        limit_price = latest_price
        # Stop loss $300 below the limit price (example, adjust as needed)
        stop_loss_price = latest_price - 300
        # Take profit $10 above the limit price (example, adjust as needed)
        take_profit_price = latest_price + 10

        # Check if the signal is a BUY signal (Signal == 1)
        if latest_signal == 1:
            print("BUY signal detected. Attempting to place order...")
            # Ensure stop loss is not below zero and take profit is above stop loss
            if stop_loss_price > 0 and take_profit_price > stop_loss_price:
                # Call the execute_trade_with_sl_tp function ONLY if it's a BUY signal
                try:
                    # Ensure Alpaca API is initialized if it's not already
                    # from alpaca.trading.client import TradingClient
                    # api = TradingClient(ALPACA_API_KEY, ALPACA_SECRET_KEY, paper=True) # Replace with your keys and paper/live setting

                    # You need to define `api` before calling this function.
                    # This part assumes `api` is already initialized elsewhere in your code.

                    # Execute the trade if the signal is BUY
                    execute_trade_with_sl_tp(
                        symbol="BTCUSD", # Use the symbol relevant to your df_btc data
                        quantity=0.001, # Example quantity, adjust as needed for BTC
                        limit_price=limit_price,
                        stop_loss_price=stop_loss_price,
                        take_profit_price=take_profit_price
                    )
                except NameError:
                     print("\nAlpaca API client 'api' is not initialized. Cannot place trade.")
                except Exception as e:
                     print(f"\nAn error occurred during trade execution attempt: {e}")

            else:
                print("Invalid stop loss or take profit prices calculated. Cannot place BUY order.")
        else:
            print("Not a BUY signal (Signal is 0). No trade executed.")

    else:
        print("DataFrame df_btc does not contain 'Close' column. Cannot define trade parameters.")

else:
    print("\nDataFrame df_btc is not available or does not contain 'Signal' column. Cannot execute trading logic.")


# The rest of your code (scheduling, logging, etc.) remains, but the trading execution
# logic is now conditional on the BUY signal.

# To enforce *only* buying, you must ensure that no 'sell' orders are ever submitted
# by your logic, except potentially for stop-loss orders on existing long positions.
# The `execute_trade_with_sl_tp` function already specifies `side='buy'`.
# So, the main requirement is to only call this function when a buy condition is met.
# The provided modification achieves this by checking `latest_signal == 1` before calling the function.

pip install flask

from flask import Flask, render_template, request
import alpaca_trade_api as tradeapi

# Alpaca paper trading credentials
API_KEY = 'PKRPJDMMFMLRJD2GZRNR'
API_SECRET = 'XsYtoTyfHkDYE2mafuskAAlbqPkuwCIjt7vVapdw'
BASE_URL = 'https://paper-api.alpaca.markets'

api = tradeapi.REST(API_KEY, API_SECRET, BASE_URL, api_version='v2')

app = Flask(__name__)

@app.route('/')
def dashboard():
    account = api.get_account()
    return render_template('dashboard.html', account=account)

@app.route('/quote', methods=['POST'])
def get_quote():
    symbol = request.form['symbol'].upper()
    try:
        price = api.get_latest_trade(symbol).price
        return render_template('dashboard.html', quote_price=price, symbol=symbol, account=api.get_account())
    except:
        return render_template('dashboard.html', error="Invalid symbol", account=api.get_account())

@app.route('/trade', methods=['POST'])
def trade():
    symbol = request.form['symbol'].upper()
    qty = int(request.form['qty'])
    side = request.form['side']

    try:
        order = api.submit_order(
            symbol=symbol,
            qty=qty,
            side=side,
            type='market',
            time_in_force='gtc'
        )
        message = f"Order placed: {side.upper()} {qty} of {symbol}"
    except Exception as e:
        message = f"Trade failed: {str(e)}"

    return render_template('dashboard.html', message=message, account=api.get_account())

if __name__ == '__main__':
    app.run(debug=True)

<!DOCTYPE html>
<html>
<head>
    <title>Alpaca Trading Dashboard</title>
</head>
<body>
    <h1>Alpaca Paper Trading Dashboard</h1>

    <h3>Account Info</h3>
    <p>Status: {{ account.status }}</p>
    <p>Equity: ${{ account.equity }}</p>
    <p>Buying Power: ${{ account.buying_power }}</p>

    <h3>Get Quote</h3>
    <form method="POST" action="/quote">
        Symbol: <input name="symbol" />
        <input type="submit" value="Get Price" />
    </form>
    {% if quote_price %}
        <p>Latest price for {{ symbol }}: ${{ quote_price }}</p>
    {% endif %}
    {% if error %}
        <p style="color:red;">{{ error }}</p>
    {% endif %}

    <h3>Place Order</h3>
    <form method="POST" action="/trade">
        Symbol: <input name="symbol" /><br />
        Quantity: <input type="number" name="qty" /><br />
        Side:
        <select name="side">
            <option value="buy">Buy</option>
            <option value="sell">Sell</option>
        </select><br />
        <input type="submit" value="Trade" />
    </form>
    {% if message %}
        <p>{{ message }}</p>
    {% endif %}
</body>
</html>

!pip install alpaca-trade-api
from alpaca_trade_api.rest import REST

# Define API keys as strings
ALPACA_API_KEY = "PKRPJDMMFMLRJD2GZRNR"
ALPACA_SECRET_KEY = "XsYtoTyfHkDYE2mafuskAAlbqPkuwCIjt7vVapdw"

# Pass the API keys to the REST constructor
api = REST(ALPACA_API_KEY, ALPACA_SECRET_KEY, base_url='https://paper-api.alpaca.markets')
api.get_account()

import alpaca_trade_api as tradeapi

# Replace with your actual API keys
ALPACA_API_KEY = "PKRPJDMMFMLRJD2GZRNR"
ALPACA_SECRET_KEY = "XsYtoTyfHkDYE2mafuskAAlbqPkuwCIjt7vVapdw"

# Create a REST object, specifying the base URL without /v2
api = tradeapi.REST(
    key_id=ALPACA_API_KEY,
    secret_key=ALPACA_SECRET_KEY,
    base_url="https://paper-api.alpaca.markets",  # Removed the extra /v2
)

# Now try fetching the account information
account = api.get_account()
print(account.status)
ALPACA_API_KEY = "PKRPJDMMFMLRJD2GZRNR"
ALPACA_SECRET_KEY = "XsYtoTyfHkDYE2mafuskAAlbqPkuwCIjt7vVapdw"

# Create a REST object, specifying the base URL without /v2
api = tradeapi.REST(
    key_id=ALPACA_API_KEY,
    secret_key=ALPACA_SECRET_KEY,
    base_url="https://paper-api.alpaca.markets",  # Removed the extra /v2
)

# Now try fetching the account information
account = api.get_account()
print(account.status)

pip install alpaca-py

python app.py

dashboard.py